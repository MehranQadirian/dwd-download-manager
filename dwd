#!/usr/bin/env python3
import subprocess
import os
import time
import sys
import urllib.parse
import requests
import argparse
from concurrent.futures import ThreadPoolExecutor
from rich.console import Console
from rich.progress import Progress, BarColumn, TextColumn, TimeRemainingColumn, TransferSpeedColumn
from rich.panel import Panel
from rich.text import Text
from rich.prompt import Prompt
from rich.table import Table
import logging
import re
import datetime
import json
import hashlib
import queue

# ØªÙ†Ø¸ÛŒÙ… Ù„Ø§Ú¯
logging.basicConfig(filename='download.log', level=logging.INFO, 
                    format='%(asctime)s - %(levelname)s - %(message)s')

console = Console()

# ØµÙ Ø¯Ø§Ù†Ù„ÙˆØ¯
download_queue = queue.Queue()

def print_welcome_message():
    welcome_text = Text("ğŸš€ DWD: The Ultimate Download Manager ğŸš€", style="bold magenta")
    console.print(Panel(welcome_text, title="Welcome", border_style="cyan", padding=(1, 2)))

def get_filename_from_url(url, is_youtube=False):
    if is_youtube:
        try:
            result = subprocess.run(['yt-dlp', '--get-filename', '-f', 'best', url], capture_output=True, text=True)
            filename = result.stdout.strip() or "youtube_download.mp4"
            return urllib.parse.unquote(filename)
        except:
            return "youtube_download.mp4"
    parsed = urllib.parse.urlparse(url)
    filename = os.path.basename(parsed.path)
    return urllib.parse.unquote(filename) if filename else "downloaded_file"

def get_file_size(url, is_youtube=False):
    if is_youtube:
        return None, 'video/mp4'
    try:
        response = requests.head(url, allow_redirects=True, timeout=10)
        size = int(response.headers.get('content-length', 0))
        content_type = response.headers.get('content-type', 'unknown')
        return size if size > 0 else None, content_type
    except Exception as e:
        console.print(Panel(f"âš ï¸ Warning: Could not get file size: {e}", style="yellow"))
        return None, 'unknown'

def get_youtube_info(url):
    try:
        result = subprocess.run(['yt-dlp', '--dump-json', url], capture_output=True, text=True)
        info = json.loads(result.stdout)
        return {
            'title': info.get('title', 'Unknown'),
            'duration': info.get('duration', 0),
            'formats': [(f.get('format_id'), f.get('ext'), f.get('resolution', 'Unknown')) for f in info.get('formats', [])]
        }
    except Exception as e:
        console.print(Panel(f"âŒ Error getting YouTube info: {e}", style="red"))
        return None

def is_youtube_url(url):
    """ØªØ´Ø®ÛŒØµ Ù„ÛŒÙ†Ú© ÛŒÙˆØªÛŒÙˆØ¨"""
    youtube_regex = r'(https?://)?(www\.)?(youtube|youtu\.be)\.'
    return bool(re.search(youtube_regex, url))

def play_completion_sound():
    try:
        subprocess.run(['mpg123', '/usr/share/sounds/freedesktop/stereo/complete.oga'], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        console.print("ğŸµ Played completion sound!", style="green")
    except:
        console.print(Panel("âš ï¸ Warning: Could not play sound. Install mpg123.", style="yellow"))

def send_notification(filename, output_path):
    try:
        subprocess.run(['notify-send', 'ğŸ‰ DWD: Download Completed', f'{filename} saved to {output_path}'], check=True)
        console.print("ğŸ“¬ Notification sent!", style="green")
    except:
        console.print(Panel("âš ï¸ Warning: Could not send notification. Install libnotify-bin.", style="yellow"))

def verify_file_integrity(file_path, expected_hash=None, hash_type='sha256'):
    if not expected_hash:
        console.print(Panel("âš ï¸ No expected hash provided. Skipping integrity check.", style="yellow"))
        return True
    try:
        hash_func = hashlib.sha256() if hash_type == 'sha256' else hashlib.md5()
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b''):
                hash_func.update(chunk)
        calculated_hash = hash_func.hexdigest()
        if calculated_hash == expected_hash:
            console.print(Panel("âœ… File integrity verified!", style="green"))
            return True
        else:
            console.print(Panel(f"âŒ File integrity check failed!\nCalculated: {calculated_hash}\nExpected: {expected_hash}", style="red"))
            return False
    except Exception as e:
        console.print(Panel(f"âŒ Error verifying integrity: {e}", style="red"))
        return False

def display_file_info(url, is_youtube, total_size, content_type, youtube_info=None):
    table = Table(title="ğŸ“‹ File Information", style="cyan", title_style="bold magenta")
    table.add_column("Field", style="cyan")
    table.add_column("Value", style="green")
    
    table.add_row("ğŸŒ URL", url)
    table.add_row("ğŸ“› Filename", get_filename_from_url(url, is_youtube))
    table.add_row("ğŸ“ Size", f"{total_size:,} bytes" if total_size else "Unknown")
    table.add_row("ğŸ“‚ Type", content_type)
    
    if is_youtube and youtube_info:
        table.add_row("ğŸ¥ Title", youtube_info['title'])
        table.add_row("â³ Duration", str(datetime.timedelta(seconds=youtube_info['duration'])))
        formats = "\n".join([f"{fmt_id}: {res} ({ext})" for fmt_id, ext, res in youtube_info['formats']])
        table.add_row("ğŸï¸ Formats", formats)
    
    console.print(table)

def download_part(url, start, end, temp_path, part_num, progress, task):
    headers = {'Range': f'bytes={start}-{end}'}
    try:
        response = requests.get(url, headers=headers, stream=True, timeout=10)
        with open(f'{temp_path}.part{part_num}', 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
                    progress.update(task, advance=len(chunk))
    except Exception as e:
        console.print(Panel(f"âŒ Error downloading part {part_num}: {e}", style="red"))
        raise

def multi_part_download(url, output_path, num_parts=4, total_size=None, progress=None, task=None):
    if not total_size:
        console.print(Panel("âš ï¸ Cannot use multi-part without known file size.", style="yellow"))
        return False
    
    part_size = total_size // num_parts
    temp_path = output_path + '.temp'
    with ThreadPoolExecutor(max_workers=num_parts) as executor:
        futures = []
        for i in range(num_parts):
            start = i * part_size
            end = start + part_size - 1 if i < num_parts - 1 else total_size - 1
            futures.append(executor.submit(download_part, url, start, end, temp_path, i, progress, task))
        
        for future in futures:
            try:
                future.result()
            except:
                return False
    
    with open(output_path, 'wb') as f:
        for i in range(num_parts):
            part_file = f'{temp_path}.part{i}'
            if os.path.exists(part_file):
                with open(part_file, 'rb') as part:
                    f.write(part.read())
                os.remove(part_file)
    
    return True

def download_file(url, output_dir, proxy=None, youtube=False, play_sound=False, quality='best', rate_limit=None, retries=3, multi_part=False, hash_check=None, hash_type='sha256'):
    is_youtube = youtube or is_youtube_url(url)
    filename = get_filename_from_url(url, is_youtube)
    output_path = os.path.join(os.path.expanduser(output_dir), filename)
    
    total_size, content_type = get_file_size(url, is_youtube)
    youtube_info = get_youtube_info(url) if is_youtube else None
    display_file_info(url, is_youtube, total_size, content_type, youtube_info)
    
    for attempt in range(retries):
        try:
            start_time = time.time()
            
            if is_youtube:
                cmd = ['yt-dlp', url, '-o', output_path, '-f', quality]
                if proxy:
                    cmd.extend(['--proxy', proxy])
                if rate_limit:
                    cmd.extend(['--limit-rate', rate_limit])
                process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            else:
                if multi_part and total_size and not is_youtube:
                    with Progress(
                        TextColumn("ğŸ“¥ {task.description}"),
                        BarColumn(bar_width=50, style="green"),
                        "[progress.percentage]{task.percentage:>3.1f}%",
                        "â€¢",
                        TransferSpeedColumn(),
                        "â€¢",
                        TimeRemainingColumn(),
                        console=console
                    ) as progress:
                        task = progress.add_task(f"[cyan]{filename} (Multi-part)", total=total_size)
                        success = multi_part_download(url, output_path, num_parts=4, total_size=total_size, progress=progress, task=task)
                        if not success:
                            raise Exception("Multi-part download failed")
                else:
                    cmd = ['wget', url, '-O', output_path, '--show-progress', '-c']
                    if proxy:
                        cmd.extend(['--proxy', proxy])
                    if rate_limit:
                        cmd.extend(['--limit-rate', rate_limit])
                    process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
                
                with Progress(
                    TextColumn("ğŸ“¥ {task.description}"),
                    BarColumn(bar_width=50, style="green"),
                    "[progress.percentage]{task.percentage:>3.1f}%",
                    "â€¢",
                    TransferSpeedColumn(),
                    "â€¢",
                    TimeRemainingColumn(),
                    console=console
                ) as progress:
                    task = progress.add_task(f"[cyan]{filename}", total=total_size)
                    
                    while not os.path.exists(output_path):
                        time.sleep(0.5)
                        if process.poll() is not None:
                            raise Exception("Process terminated early")
                    
                    while process.poll() is None:
                        if os.path.exists(output_path):
                            current_size = os.path.getsize(output_path)
                            if total_size:
                                progress.update(task, completed=current_size)
                            else:
                                progress.update(task, description=f"[cyan]{filename} ({current_size:,} bytes)")
                        time.sleep(0.5)
                    
                    if os.path.exists(output_path):
                        final_size = os.path.getsize(output_path)
                        if total_size:
                            progress.update(task, completed=final_size, total=final_size)
                        else:
                            progress.update(task, description=f"[cyan]{filename} ({final_size:,} bytes)")
                    
                    stdout, stderr = process.communicate()
                    if process.returncode != 0:
                        raise Exception(f"Download error: {stderr}")
            
            elapsed_time = time.time() - start_time
            final_size = os.path.getsize(output_path) if os.path.exists(output_path) else 0
            avg_speed = final_size / elapsed_time / 1024 if elapsed_time > 0 else 0  # KB/s
            
            if hash_check and not verify_file_integrity(output_path, hash_check, hash_type):
                os.remove(output_path)
                raise Exception("Integrity check failed")
            
            success_text = Text(
                f"ğŸ‰ Download completed: {filename}\n"
                f"ğŸ“ Size: {final_size:,} bytes\n"
                f"ğŸ“‚ Path: {output_path}\n"
                f"âš¡ Average Speed: {avg_speed:.2f} KB/s\n"
                f"â±ï¸ Time Taken: {datetime.timedelta(seconds=int(elapsed_time))}",
                style="bold green"
            )
            console.print(Panel(success_text, title="âœ… Success", border_style="green", padding=(1, 2)))
            logging.info(f"Downloaded {url} to {output_path} ({final_size:,} bytes, avg speed: {avg_speed:.2f} KB/s)")
            
            if play_sound:
                play_completion_sound()
            send_notification(filename, output_path)
            
            return True
        
        except Exception as e:
            console.print(Panel(f"âš ï¸ Attempt {attempt + 1}/{retries} failed: {e}. Retrying...", style="yellow"))
            time.sleep(2 ** attempt)  # Exponential backoff
    
    console.print(Panel(f"âŒ Failed to download {url} after {retries} attempts.", style="red"))
    logging.error(f"Failed to download {url} after {retries} attempts")
    return False

def add_to_queue(urls):
    for url in urls:
        download_queue.put(url)
    console.print(Panel(f"âœ… Added {len(urls)} URLs to download queue.", style="green"))

def process_queue(output_dir, proxy, youtube, sound, quality, rate_limit, retries, multi_part, hash_check, hash_type):
    console.print(Panel(f"ğŸ“‹ Processing download queue ({download_queue.qsize()} items)", style="cyan"))
    while not download_queue.empty():
        url = download_queue.get()
        download_file(url, output_dir, proxy, youtube, sound, quality, rate_limit, retries, multi_part, hash_check, hash_type)
    console.print(Panel("ğŸ‰ All queued downloads completed!", style="green"))

def read_urls_from_file(file_path):
    try:
        with open(file_path, 'r') as f:
            urls = [line.strip() for line in f if line.strip()]
        console.print(Panel(f"âœ… Loaded {len(urls)} URLs from {file_path}", style="green"))
        return urls
    except Exception as e:
        console.print(Panel(f"âŒ Error reading input file: {e}", style="red"))
        return []

def interactive_menu():
    while True:
        console.print(Panel("ğŸ“‹ DWD Menu", title="Menu", style="cyan"))
        console.print("1ï¸âƒ£ Download a single URL")
        console.print("2ï¸âƒ£ Download from file")
        console.print("3ï¸âƒ£ Add URLs to queue")
        console.print("4ï¸âƒ£ Process download queue")
        console.print("5ï¸âƒ£ Exit")
        
        choice = Prompt.ask("Enter your choice", choices=["1", "2", "3", "4", "5"], default="1")
        
        if choice == "1":
            url = Prompt.ask("ğŸŒ Enter URL")
            output_dir = Prompt.ask("ğŸ“‚ Output directory", default="~/Downloads")
            quality = Prompt.ask("ğŸ¥ YouTube quality (if applicable)", default="best")
            play_sound = Prompt.ask("ğŸµ Play sound on completion? (y/n)", default="n") == "y"
            multi_part = Prompt.ask("ğŸ“¦ Use multi-part download? (y/n)", default="n") == "y"
            download_file(url, output_dir, quality=quality, play_sound=play_sound, multi_part=multi_part)
        
        elif choice == "2":
            file_path = Prompt.ask("ğŸ“„ Path to URL file")
            output_dir = Prompt.ask("ğŸ“‚ Output directory", default="~/Downloads")
            quality = Prompt.ask("ğŸ¥ YouTube quality (if applicable)", default="best")
            play_sound = Prompt.ask("ğŸµ Play sound on completion? (y/n)", default="n") == "y"
            multi_part = Prompt.ask("ğŸ“¦ Use multi-part download? (y/n)", default="n") == "y"
            urls = read_urls_from_file(file_path)
            with ThreadPoolExecutor(max_workers=3) as executor:
                futures = [executor.submit(download_file, url, output_dir, quality=quality, play_sound=play_sound, multi_part=multi_part) for url in urls]
                for future in futures:
                    future.result()
        
        elif choice == "3":
            urls = Prompt.ask("ğŸŒ Enter URLs (comma-separated)").split(',')
            add_to_queue([url.strip() for url in urls])
        
        elif choice == "4":
            output_dir = Prompt.ask("ğŸ“‚ Output directory", default="~/Downloads")
            quality = Prompt.ask("ğŸ¥ YouTube quality (if applicable)", default="best")
            play_sound = Prompt.ask("ğŸµ Play sound on completion? (y/n)", default="n") == "y"
            multi_part = Prompt.ask("ğŸ“¦ Use multi-part download? (y/n)", default="n") == "y"
            process_queue(output_dir, None, False, play_sound, quality, None, 3, multi_part, None, 'sha256')
        
        elif choice == "5":
            console.print(Panel("ğŸ‘‹ Goodbye!", style="cyan"))
            sys.exit(0)

def main():
    parser = argparse.ArgumentParser(description="ğŸš€ DWD: The Ultimate Download Manager ğŸš€")
    parser.add_argument('--interactive', '-i', action='store_true', help="Run in interactive mode")
    parser.add_argument('urls', nargs='*', help="One or more URLs to download")
    parser.add_argument('--output-dir', '-o', default='~/Downloads', help="Directory to save downloaded files")
    parser.add_argument('--proxy', '-p', help="Proxy server (e.g., http://proxy:port)")
    parser.add_argument('--threads', '-t', type=int, default=3, help="Number of parallel downloads")
    parser.add_argument('--youtube', '-y', action='store_true', help="Force YouTube download mode with yt-dlp")
    parser.add_argument('--sound', '-s', action='store_true', help="Play a sound when download completes")
    parser.add_argument('--quality', '-q', default='best', help="YouTube video quality (e.g., best, 720p, 1080p)")
    parser.add_argument('--rate-limit', '-r', help="Limit download speed (e.g., 500k, 1m)")
    parser.add_argument('--retries', type=int, default=3, help="Number of retry attempts")
    parser.add_argument('--multi-part', '-m', action='store_true', help="Use multi-part download for large files")
    parser.add_argument('--hash-check', help="Expected hash for integrity check")
    parser.add_argument('--hash-type', default='sha256', choices=['sha256', 'md5'], help="Hash type for integrity check")
    parser.add_argument('--input-file', help="Text file containing URLs to download")
    parser.add_argument('--queue', action='store_true', help="Add URLs to queue instead of immediate download")
    
    args = parser.parse_args()
    
    print_welcome_message()
    
    if args.interactive:
        interactive_menu()
        return
    
    urls = args.urls
    if args.input_file:
        urls.extend(read_urls_from_file(args.input_file))
    
    if args.queue:
        add_to_queue(urls)
        process_queue(args.output_dir, args.proxy, args.youtube, args.sound, args.quality, args.rate_limit, args.retries, args.multi_part, args.hash_check, args.hash_type)
    else:
        with ThreadPoolExecutor(max_workers=args.threads) as executor:
            futures = [executor.submit(download_file, url, args.output_dir, args.proxy, args.youtube, args.sound, args.quality, args.rate_limit, args.retries, args.multi_part, args.hash_check, args.hash_type) for url in urls]
            for future in futures:
                future.result()
    
    console.print(Panel("ğŸ‰ All downloads completed!", style="green"))

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print(Panel("âš ï¸ Download interrupted by user.", style="yellow"))
        logging.warning("Download interrupted by user")
        sys.exit(1)
    except Exception as e:
        console.print(Panel(f"âŒ Unexpected error: {e}", style="red"))
        logging.error(f"Unexpected error: {e}")
        sys.exit(1)